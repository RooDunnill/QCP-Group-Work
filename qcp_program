import time
start = time.time()
import numpy as np                                              #mostly used to make 1D arrays
import random as rm                                             #used for measuring
import atexit
import matplotlib.pyplot as plt
from rich.console import Console
from rich.theme import Theme
import cProfile

custom_theme = Theme({"Qubit_style":"spring_green4",               #creates nice colours for the print out
                      "Prob_dist_style":"green4",
                      "Gate_style":"dark_green",
                      "Density_style":"chartreuse4",
                      "info":"grey62",
                      "error":"dark_orange",
                      "measure":"green1",
                      "headers":"dark_goldenrod"})
console = Console(style="none",theme=custom_theme, highlight=False)

def prog_end():    #made it to make the code at the end of the program a little neater
    stop = time.time()
    interval: float = stop - start
    console.print(f"{interval:.3f} seconds elapsed",style="info")
    plt.show()
atexit.register(prog_end)

console.rule(style="headers")     #creates the start message
console.rule(f"Quantum Computer Simulator", style="headers")
console.rule(style="headers")
console.print("""Welcome to our Quantum Computer Simulator,
here you can simulate a circuit with any amount of gates and qubits.
You can define your own algorithm in a function and also 
define any gate with the universal gate class. 
The current convention of this program, is that the "first"
gate to be multiplied is at the bottom in a Quantum Circuit.
Now printing the values of the computation:""",style="info")
print("\n \n")

class qc_dat:                    #defines a class to store variables in to recall from so that its all
    C_Not_info = """This gate is used to change the behaviour of one qubit based on another. 
    This sepecific function is mostly obselete now, it is preferred to use the C Gate class instead"""       #C_Not is mostly obsolete due to new C Gate class       #in one neat area
    C_Not_matrix = [1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0]#2 Qubit CNot gate in one configuration, need to add more
    X_Gate_info = "Used to flip the Qubit in the X basis. Often seen in the CNot gate."                             
    Y_Gate_info = "Used to flip the Qubit in the Y basis."       
    Z_Gate_info = "Used to flip the Qubit in the Z basis. This gate flips from 1 to 0 in the computational basis."                           
    Hadamard_info = """The Hadamard gate is one of the most useful gates, used to convert the Qubit from
    the computation basis to the plus, minus basis. When applied twice, it can lead back to its original value/
    acts as an Identity matrix."""
    U_Gate_info = """This is a gate that can be transformed into most elementary gates using the constants a,b and c.
    For example a Hadamard gate can be defined with a = pi, b = 0 and c = pi while an X Gate can be defined by
     a = pi/2 b = 0 and c = pi. """
    Identity_info = """
    Identity Matrix: This matrix leaves the product invariant after multiplication.
    It is mainly used in this program to increase the dimension
    of other matrices. This is used within the tensor products when
    a Qubit has no gate action, but the others do."""
    error_class = "the operation is not with the correct class"
    error_mat_dim = "the dimensions of the matrices do not share the same value"
    error_value = "the value selected is outside the correct range of options"
    error_qubit_num = "you can't select the same qubit for both inputs of the operation gate and control gate."
    error_qubit_pos = "one of the selected qubits must be 1 which represents the top left of the matrix rather than qubit 1."
    Density_matrix_info = "test"
    prob_dist_info = "this is a matrix of the probability of each measurement occuring within a group of qubits."
    error_trace = "the trace does not equal 1 and so the calculation has gone wrong somewhere."
    error_imag_prob = "the probability must be all real values."
    error_norm = "the sum of these values must equal 1 to preserve probability."
    error_iterations = "to customise the iterations value, you must provide the number of qubits used in the search"
    qubit_info = """The Qubit is the quantum equivalent to the bit. However, due to the nature of 
    Quantum Mechanics, it can take any value rather than just two. However, by measuring the state
    in which it is in, you collapse the wavefunction and the Qubit becomes 1 of two values, 1 or 0."""
    gate_info = """Gates are used to apply an operation to a Qubit. 
    They are normally situated on a grid of n Qubits.
    Using tensor products, we can combine all the gates 
    at one time instance together to create one unitary matrix.
    Then we can matrix multiply successive gates together to creat one
    universal matrix that we can apply to the Qubit before measuring"""
    errror_mixed_state = "the mixed states must each have their own probability values"

class QC_error(Exception):                 #a custom error class to raise custom errors from qc_dat
    """Creates my own custom errors defined in qc_dat."""
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

    def __str__(self):
        return f"{self.message}"
 
def trace(matrix):                #calculates the trace of a matrix, either for a gate class or for a normal array
    """Just computes the trace of a matrix, mostly used as a checker"""
    if isinstance(matrix, Gate):
        tr = 0
        for i in range(matrix.dim):
            tr += matrix.matrix[i+i*matrix.dim]
        return tr
    elif isinstance(matrix, np.ndarray):
        dim = int(np.sqrt(len(matrix)))
        tr = 0
        for i in range(dim):
            tr += matrix[i+i*dim]
        return tr
    else:
        raise QC_error(qc_dat.error_class)
    

def is_real(obj):                 #pretty irrelevant but is used for checking probs are real
    if isinstance(obj, complex):
        if np.imag(obj) < 1e-5:
            return True
    elif isinstance(obj, (int, float)):
        return True
    else:
        return False

class Qubit:                                           #creates the qubit class
    def __init__(self, **kwargs) -> None:
        self.state_type = kwargs.get("type", "pure")                   #the default qubit is a single pure qubit |0>
        self.name = kwargs.get("name","|0>")
        self.vector = np.array(kwargs.get("vector",np.array([1,0])),dtype=np.complex128)
        self.dim = len(self.vector)                    #used constantly in all calcs so defined it universally
        self.shift = self.dim.bit_length() - 1
        self.density = None
        if self.state_type == "mixed":
            self.vector = np.array(kwargs.get("vectors",[]),dtype = np.complex128)
            self.weights = kwargs.get("weights", [])
            if len(self.weights) != len(self.vector):
                raise QC_error(qc_dat.errror_mixed_state)
        elif self.state_type == "seperable":             #creates the seperable states
            qubit_states = np.array(kwargs.get("vectors",[]))
            if isinstance(qubit_states[0], np.ndarray):                         #creates the vector for the seperable states for custom vector states
                qubit_states = np.array(kwargs.get("vectors",[]), dtype = np.complex128)
                self.vector = qubit_states[0]
                for state in qubit_states[1:]:
                    self.vector = self @ state
                self.name = f"Seperable state of custom states"
            elif isinstance(qubit_states[0], Qubit):                          #creates a seperable state for the tensor of qubits together
                self.vector = qubit_states[0].vector
                for state in qubit_states[1:]:
                    self.vector = self @ state.vector
                    self_name_size = int(np.log2(self.dim))
                    state_name_size = int(np.log2(state.dim))
                    self.name = f"|{self.name[1:self_name_size]}{state.name[1:state_name_size+1]}>"
            else:
                raise QC_error(qc_dat.error_class)
        else:
            pass

    @classmethod                 #creates the default qubits, using class methods allows you to define an instance within the class
    def q0(cls):
        q0_vector = [1,0]
        return cls(name="|0>", vector=q0_vector)

    @classmethod
    def q1(cls):
        q1_vector = [0,1]
        return cls(name="|1>", vector=q1_vector)

    @classmethod
    def qp(cls):
        n = 1/np.sqrt(2)
        qp_vector = [n,n]
        return cls(name="|+>", vector=qp_vector)

    @classmethod
    def qm(cls):
        n = 1/np.sqrt(2)
        qm_vector = [n,-n]
        return cls(name="|->", vector=qm_vector)
        
    def __str__(self):
        return f"{self.name}\n{self.vector}"   #did this so that the matrix prints neatly
    
    def __rich__(self):
        return f"[bold]{self.name}[/bold]\n[not bold]{self.vector}[/not bold]"
    
    def __matmul__(self, other):               #this is an n x n tensor product function
        if isinstance(other, Qubit):           #although this tensors are all 1D   
            self_name_size = int(np.log2(self.dim))
            other_name_size = int(np.log2(other.dim))
            new_name = f"|{self.name[1:self_name_size+1]}{other.name[1:other_name_size+1]}>"
            new_length: int = self.dim*other.dim
            new_vector = np.zeros(new_length,dtype=np.complex128)
            other_shift = other.dim.bit_length() - 1
            for i in range(self.dim):     #multiplies the second ket by each value in the first ket
                for j in range(other.dim):          #iterates up and down the second ket
                    new_vector[j+(i << other_shift)] += self.vector[i]*other.vector[j] #adds the values into each element of the vector
            return Qubit(name=new_name, vector=np.array(new_vector))    #returns a new Qubit instance with a new name
        elif isinstance(other, np.ndarray):                 #used for when you just need to compute it for a given array, this is for creating seperable states
            other_dim = len(other)
            self_name_size = int(np.log2(self.dim))
            other_name_size = int(np.log2(other_dim))
            new_name = f""
            new_length: int = self.dim*other_dim
            new_vector = np.zeros(new_length,dtype=np.complex128)
            for i in range(self.dim):     #multiplies the second ket by each value in the first ket
                for j in range(other_dim):          #iterates up and down the second ket
                    new_vector[j+(i * other_dim)] += self.vector[i]*other[j] #adds the values into
            self.dim = new_length
            return np.array(new_vector)    #returns a new Object with a new name too
        else:
            raise QC_error(qc_dat.error_class)

    def __ipow__(self, other):                 #denoted **=
        if isinstance(self, Qubit):  
            self = self @ other
            return self
        elif isinstance(self, Qubit.vector):
            print(test2)
        else:
            raise QC_error(qc_dat.error_class)

    def norm(self):                 #dunno why this is here ngl, just one of the first functions i tried
        normalise = np.sqrt(sum([i*np.conj(i) for i in self.vector]))
        self.vector = self.vector/normalise

    def qubit_info(self):      
        print(qc_dat.qubit_info)

    def density_mat(self):                     #will soon be replaced by the Density_matrix class
        new_name =f"Density matrix of qubit {self.name}"
        new_mat = np.zeros(self.dim*self.dim,dtype=np.complex128)
        qubit_conj = np.conj(self.vector)
        for i in range(self.dim):
            for j in range(self.dim):
                new_mat[j+(i << self.shift)] += qubit_conj[i]*self.vector[j]
        den = Density(new_name, qc_dat.Density_matrix_info, new_mat)
        if abs(1 -trace(den)) < 1e-5:
            return den
        else:
            raise QC_error(qc_dat.error_trace)

    def prob_state(self, meas_state=None, final_gate=None) -> float:             #find the prob of getting a specific state, will probably be replaced at some point
        global is_real
        if meas_state:
            if isinstance(self, Qubit) and isinstance(meas_state, Qubit):
                projector = meas_state.density_mat()
                if final_gate:
                    if isinstance(final_gate, Gate):
                        final_state = final_gate * self
                    else:
                        raise QC_error(qc_dat.error_class)
                else:
                    final_state = self
                den = final_state.density_mat()
                probability = trace(projector * den)
                is_real = np.isreal(probability)
                if is_real is True:
                    return probability
                else:
                    if np.imag(probability) < 1e-5:
                        return probability
                    else:
                        raise QC_error(qc_dat.error_imag_prob)
            else:
                raise QC_error(qc_dat.error_class)

    def prob_dist(self, final_gate=None):            #creates a table with the prob of each state occuring, only works for projective measurements
        new_mat = np.zeros(self.dim,dtype=np.float64)
        if isinstance(self, Qubit):
            norm = 0
            if final_gate:
                if isinstance(final_gate, Gate):
                    new_name = f"PD for {self.name} applied to Circuit:"
                    new_state = final_gate * self             #creates the new state vector
                    state_conj = np.conj(new_state.vector)
                    for i in range(self.dim):             #basically squares the vector components to get the prob of each
                        new_mat[i] = (new_state.vector[i]*state_conj[i]).real
                        norm += new_mat[i]
                else:
                    raise QC_error(qc_dat.error_class)
            else:
                qubit_conj = np.conj(self.vector)
                new_name = f"PD for {self.name}"
                for i in range(self.dim):
                    new_mat[i] = (self.vector[i]*qubit_conj[i]).real        #just does the squaring without any external matrices applied
                    norm += new_mat[i]
            if np.isclose(norm, 1.0, atol=1e-5):
                return Prob_dist(new_name, qc_dat.prob_dist_info, np.array(new_mat))
            else:
                raise QC_error(qc_dat.error_norm)
        else:
            raise QC_error(qc_dat.error_class)

    def measure(self, final_gate=None):         #randomly picks a state from the weighted probabilities, can also apply the gate within it, which is a bit redundant
        if isinstance(self, Qubit):
            sequence = np.arange(0,self.dim)
            if final_gate:
                if isinstance(final_gate, Gate):
                    PD = self.prob_dist(final_gate)
                    measurement = int(rm.choices(sequence, weights=PD.matrix)[0])   #randomly picks a value based on the weighted probabilities
                else:
                    raise QC_error(qc_dat.error_class)
            else:
                PD = self.prob_dist()
                measurement = int(rm.choices(sequence, weights=PD.matrix)[0])
            num_bits = int(np.ceil(np.log2(self.dim)))
            measurement = f"Measured the state: |{bin(measurement)[2:].zfill(num_bits)}>"
            return measurement

    def bloch_plot(self):  #turn this into a class soon, pretty useless but might be worth for report or presentation
        plot_counter = 0
        vals = np.zeros(2,dtype=np.complex128)
        vals[0] = self.vector[0]
        vals[1] = self.vector[1]
        plotted_qubit = Qubit(vector=vals)
        den_mat = plotted_qubit.density_mat()
        x = 2*np.real(den_mat.matrix[1])
        y = 2*np.imag(den_mat.matrix[2])
        z = den_mat.matrix[0] - den_mat.matrix[3]
        ax = plt.axes(projection="3d")
        ax.quiver(0,0,0,x,y,z)
        u, v = np.mgrid[0:2*np.pi:50j, 0:np.pi:50j]
        x_sp = np.cos(u)*np.sin(v)
        y_sp = np.sin(u)*np.sin(v)
        z_sp = np.cos(v)
        ax.set_xlabel("X_Axis")
        ax.set_ylabel("Y Axis")
        ax.set_zlabel("Z Axis")
        ax.set_title("Bloch Sphere")
        ax.plot_surface(x_sp, y_sp, z_sp, color="g", alpha=0.3)
        ax.axes.grid(axis="x")
        ax.text(0,0,1,"|0>")
        ax.text(0,0,-1,"|1>")
        ax.text(1,0,0,"|+>")
        ax.text(-1,0,0,"|->")
        ax.text(0,1,0,"|i>")
        ax.text(0,-1,0,"|-i>")
        ax.plot([-1,1],[0,0],color="black")
        ax.plot([0,0],[-1,1],color="black")
        ax.plot([0,0],[-1,1],zdir="y",color="black")
        plot_counter += 1
        
q0 = Qubit.q0()
q1 = Qubit.q1()
qp = Qubit.qp()
qm = Qubit.qm()

class Gate:            #creates a gate class to enable unique properties
    def __init__(self, **kwargs):
        self.name = kwargs.get("name", "")
        self.matrix = np.array(kwargs.get("matrix",[]),dtype=np.complex128)
        self.info = kwargs.get("info", "")
        self.length = kwargs.get("len", len(self.matrix))          #naming these matrices and qubits vectors was a stupid idea XD
        self.dim = kwargs.get("dim", int(np.sqrt(self.length)))
        self.shift = self.dim.bit_length() - 1

    @classmethod                #again creates some of the default gates, for ease of use and neatness
    def X_Gate(cls):
        X_matrix = [0,1,1,0]
        return cls(name="X Gate", matrix=X_matrix,info=qc_dat.X_Gate_info)
    
    @classmethod
    def Y_Gate(cls):
        Y_matrix = [0,np.complex128(0-1j),np.complex128(0+1j),0]
        return cls(name="Y Gate", matrix=Y_matrix,info=qc_dat.Y_Gate_info)

    @classmethod
    def Z_Gate(cls):
        Z_matrix = [1,0,0,-1]
        return cls(name="Z Gate", matrix=Z_matrix, info=qc_dat.Z_Gate_info)

    @classmethod
    def Identity(cls, **kwargs):                     #eventually want to make this so its n dimensional
        Id_matrix = [1,0,0,1]
        return cls(name="Identity Gate", matrix=Id_matrix, info=qc_dat.Identity_info)
    
    @classmethod          
    def Hadamard(cls):
        n = 1/np.sqrt(2)
        H_matrix = [n,n,n,-n]
        return cls(name="Hadamard", matrix=H_matrix, info=qc_dat.Hadamard_info)

    @classmethod                                        #allows for the making of any phase gate of 2 dimensions
    def P_Gate(cls, theta):
        P_matrix = [1,0,0,np.exp(np.complex128(0-1j)*theta)]
        return cls(name=f"Phase Gate with a phase {theta:.3f}", matrix=P_matrix)

    @classmethod                                #allows for any unitary gates with three given variables
    def U_Gate(cls, a, b, c):
        U_matrix = [np.cos(a/2),
                    -np.exp(np.complex128(0-1j)*c)*np.sin(a/2),
                    np.exp(np.complex128(0+1j)*b)*np.sin(a/2),
                    np.exp(np.complex128(0+1j)*(b+c))*np.cos(a/2)]
        return cls(name=f"Unitary Gate with values (a:{a:.3f}, b:{b:.3f}, c:{c:.3f})", matrix=U_matrix)

    @classmethod                             #creates any specific control gate
    def C_Gate(cls, **kwargs):
        qubit1 = kwargs.get("qubit1", 1)
        qubit2 = kwargs.get("qubit2", 2)
        gate_action = kwargs.get("gate_action", X_Gate)
        qubit_dist = int(qubit1 - qubit2)
        if qubit1 == 1 or qubit2 == 1:                   #either creates an inverted one or a "normal" one
            if qubit_dist < 0:
                i = 0                                     #THE INVERTED CONTROL GATE MAY BE IMPLEMENTED WRONG
                Id = Identity
                while i < int(abs(qubit_dist) - 1):
                    Id += Identity
                    i += 1
                new_mat = Id + gate_action
            elif qubit_dist > 0:
                i = 0
                Id = gate_action
                while i < int(abs(qubit_dist)):
                    Id += Identity
                    i += 1
                new_mat = Id
            else:
                raise QC_error(qc_dat.error_qubit_num)
        else:
            raise QC_error(qc_dat.error_qubit_pos)
        C_dim = int(abs(qubit_dist)*Identity.dim+gate_action.dim)
        C_length = C_dim*C_dim
        return cls(name=f"Control {gate_action.name}", matrix=new_mat.matrix, dim=C_dim, len=C_length)


    def __str__(self):
        return f"{self.name}\n{self.matrix}"

    def __rich__(self):
        return f"[bold]{self.name}[/bold]\n[not bold]{self.matrix}[/not bold]"
    

    def __matmul__(self, other):      #adopts the matmul notation to make an easy tensor product of two square matrices
        if isinstance(other, Gate):
            new_info = "This is a tensor product of gates: "f"{self.name}"" and "f"{other.name}"
            new_name = f"{self.name} @ {other.name}"
            new_length = self.length*other.length
            new_mat = np.zeros(new_length,dtype=np.complex128)
            new_shift = (self.dim*other.dim).bit_length() - 1
            comb_shift = other.shift + new_shift
            for m in range(self.dim):
                for i in range(self.dim):
                    for j in range(other.dim):             #4 is 100 2 is 10
                        for k in range(other.dim):   #honestly, this works but is trash and looks like shit
                            new_mat[k+(j << new_shift)+(i << other.shift)+(m << comb_shift)] += self.matrix[i+(m << self.shift)]*other.matrix[k+(j << other.shift)]
            return Gate(name=new_name, info=new_info, matrix=np.array(new_mat))
        else:
            raise QC_error(qc_dat.error_class)

    def __ipow__(self, other):    #denoted **=
        if isinstance(self, Gate):  
            self = self @ other
            return self
        else:
            raise QC_error(qc_dat.error_class)
        

    def __mul__(self, other):       #matrix multiplication
        if isinstance(self, Gate):
            if isinstance(other, Gate):    #however probs completely better way to do this so might scrap at some point
                _summ = 0
                if self.dim == other.dim:
                    new_info = "This is a matrix multiplication of gates: "f"{self.name}"" and "f"{other.name}"
                    new_name = f"{self.name} * {other.name}"
                    new_mat = np.zeros(self.length,dtype=np.complex128)
                    for i in range(self.dim):
                        for k in range(self.dim):
                            for j in range(self.dim):    #again a mess and done in a different manner to tensor product
                                _summ += (self.matrix[j+(i * other.dim)]*other.matrix[k+(j * self.dim)])
                            new_mat[k+(i << self.shift)] += _summ
                            _summ = 0
                    if isinstance(other, Density):
                        new_info = "This is the density matrix of: "f"{self.name}"" and "f"{other.name}"
                        return Density(new_name, new_info, new_mat)
                    else:
                        return Gate(name=new_name, info=new_info, matrix=np.array(new_mat))
                else:
                    raise QC_error(qc_dat.error_mat_dim)
            elif isinstance(other, Qubit):  #splits up based on type as this isnt two n x n but rather n x n and n matrix
                _summ = 0
                if self.dim == other.dim:
                    new_name = f"{self.name}{other.name}"
                    new_mat = np.zeros(self.dim,dtype=np.complex128)
                    for i in range(self.dim):
                        for j in range(self.dim):
                            _summ += (self.matrix[j+(i * other.dim)]*other.vector[j])
                        new_mat[i] += _summ
                        _summ = 0
                    return Qubit(name=new_name, vector=np.array(new_mat))
                else:
                    raise QC_error(qc_dat.error_mat_dim)
            else:
                raise QC_error(qc_dat.error_class)
        else:
            raise QC_error(qc_dat.error_class)
    
    def __add__(self, other):         #direct sum                   
        if isinstance(other, Gate):                   #DONT TOUCH WITH THE BINARY SHIFTS AS THIS ISNT IN POWERS OF 2
            new_info = "This is a direct sum of gates: "f"{self.name}"" and "f"{other.name}"
            new_name = f"{self.name} + {other.name}"
            new_dim = self.dim + other.dim
            new_length = new_dim**2
            new_mat = np.zeros(new_length,dtype=np.complex128)
            for i in range(self.dim):
                for j in range(self.dim):                   #a lot more elegant
                    new_mat[j+new_dim*i] += self.matrix[j+self.dim*i]
            for i in range(other.dim):     #although would be faster if i made a function to apply straight
                for j in range(other.dim):    #to individual qubits instead
                    new_mat[self.dim+j+self.dim*new_dim+new_dim*i] += other.matrix[j+other.dim*i]
            return Gate(name=new_name, matrix=np.array(new_mat), info=new_info)
        else:
            raise QC_error(qc_dat.error_class)
    
    def __iadd__(self, other):
        if isinstance(other, Gate):
            self = self + other
            return self
        else:
            raise QC_error(qc_dat.error_class)
        
    def gate_info(self):
        print(qc_dat.gate_info)


        

class Density(Gate):       #makes a matrix of the probabilities, useful for entangled states
    def __init__(self, **kwargs):
        self.name = kwargs.get("name", "")
        self.qubit = kwargs.get("qubit", "")
        self.state_type = kwargs.get("type", "pure")
        self.q_vector = self.qubit.vector
        self.dim = self.qubit.dim
        self.length = self.dim**2
        self.shift = self.dim.bit_length() - 1
        self.rho = kwargs.get("rho", self.construct_density_matrix())
        

    def __str__(self):
        return f"{self.name}\n{self.rho}"
    
    def __rich__(self):
        return f"[bold]{self.name}[/bold]\n[not bold]{self.rho}[/not bold]"
    
    def construct_density_matrix(self):
        if self.qubit.state_type == "pure":
            self.state_type == "pure"
            return self.pure_state()
        elif self.qubit.state_type == "seperable":
            self.state_type == "seperable"
            return self.pure_state()
        
        #     if state_type == "entangled":
        #    return self.entangled_state()
        #elif state_type == "mixed":
        #    return self.mixed_state()
        #elif state_type == "seperable":
        #    return self.seperable_state()
        #else:
        
    def pure_state(self, **kwargs):       #taken from the old density matrix function
        if isinstance(self, Density):
            if self.qubit.name != "":
                self.name =f"Density matrix of qubit {self.qubit.name}"
            rho = np.zeros(self.dim*self.dim,dtype=np.complex128)
            qubit_conj = np.conj(self.q_vector)
            for i in range(self.dim):
                for j in range(self.dim):
                    rho[j+(i << self.shift)] += qubit_conj[i]*self.q_vector[j]
            if abs(1 -trace(rho)) < 1e-5:
                return rho
            else:
                raise QC_error(qc_dat.error_trace)

    






    def __and__(self, other):
        new_name = f"{self.name} + {other.name}"
        new_mat = np.zeros(self.length,dtype=np.complex128)
        if isinstance(self, Density) and isinstance(other, Density):
            for i in range(self.length):
                new_mat[i] = self.matrix[i] + other.matrix[i]
            return Density(new_name, qc_dat.Density_matrix_info, np.array(new_mat))
        else:
            raise QC_error(qc_dat.error_class)

class Prob_dist(Qubit):          #used mostly for isinstance functions
    def __init__(self, name, info, matrix):
        self.name = name
        self.info = info
        self.matrix = matrix
        self.dim = len(self.matrix)
    
    def __str__(self):
        return f"{self.name}\n{self.matrix}"
    
    def __rich__(self):
        return f"[bold]{self.name}[/bold]\n[not bold]{self.matrix}[/not bold]"

class Grover():                                               #this is the Grover algorithms own class
    def __init__(self, oracle_values, **kwargs):
        self.n_cap = int(kwargs.get("qubit_cap",10))             #DONT ALLOW THIS BEYOND 12 DUE TO COMPUTATIONAL ISSUES
        self.n = int(kwargs.get("n", 0))
        self.it = int(kwargs.get("iterations", 0))               #ANY MORE THAN 85ISH CRASHES FOR NOW
        self.oracle_values = oracle_values
        self.results = kwargs.get("results", [])

    def __str__(self):
        return f"{self.name}\n{self.results}"
    
    def __rich__(self):           #creates the correct printout so it shows the prob next to the ket written in ket notation
        num_bits = int(np.ceil(self.n))
        print_out = f"[bold]{self.name}[/bold]\n"
        for ket_val, prob_val in zip(self.results[:,0],self.results[:,1]):
            print_out += (f"State |{bin(ket_val)[2:].zfill(num_bits)}> ({ket_val}) with a prob val of: {prob_val:.{3}f}\n")
        return print_out

    def phase_oracle(self, qub, oracle_values):          #the Grover phase oracle
        flip = np.ones(qub.dim)
        for i in oracle_values:
            flip[i] = flip[i] - 2
        for j, vals in enumerate(flip):
            qub.vector[j] = qub.vector[j] * vals        
        return qub

    def top_probs(self, prob_list, n):             #sorts through the probability distribution and finds the top n probabilities corresponding to the length n or the oracle values
        top_n = np.array([], dtype=prob_list.dtype)
        temp_lst = prob_list.copy()  
        for _ in range(n):
            max_value = np.max(temp_lst)
            top_n = np.append(top_n, max_value)
            temp_lst = np.delete(temp_lst, np.argmax(temp_lst))
        result = []
        used_count = {} 
        for i, num in enumerate(prob_list):
            if num in top_n and used_count.get(num, 0) < np.count_nonzero(top_n == num):        #this accounts for if you have two numbers with the same value
                result.append((i, num))
                used_count[num] = used_count.get(num, 0) + 1
        return np.array(result, dtype=object)

    def run(self):     #Grovers algorithm, can input the number of qubits and also a custom amount of iterations
        console.rule(f"Grovers search with oracle values: {self.oracle_values}", style="headers")
        spec_had_mat = np.array([1,1,1,-1])    #i use this so that all the matrix mults are by an integer value and not a float and then apply the float later
        spec_had = Gate(name="Custom Hadamard for Grovers", info=qc_dat.Hadamard_info, matrix=spec_had_mat)
        if self.n == 0:               #if the number of qubits required is not given then run:
            print_array(f"Using up to {self.n_cap} Qubits to run the search")
            if self.it == 0:           #if an iteration count is not given then run:
                max_oracle = max(self.oracle_values)
                n_qubit_min = 1
                search_space = 2
                while max_oracle > 2**n_qubit_min:             #when picking the qubits, we need enough to allow the search space to be bigger than all the oracle values
                    n_qubit_min += 1
                n_qubit_range = np.arange(n_qubit_min, self.n_cap + 1, dtype=int)
                int_val = 0
                for i in n_qubit_range:   #goes through the range of possible qubit values from the smallest possible for the given oracle values up to the cap
                    search_space = 2**i   #computes the search space for the given qubit value
                    op_iter = ((np.pi/4)*np.sqrt((search_space)/len(self.oracle_values)) - 0.5)     #can probs make this not be defined in so many places
                    int_dist = op_iter - np.floor((np.pi/4)*np.sqrt((search_space)/len(self.oracle_values)) - 0.5)  #finds the float value
                    int_dist = abs(int_dist-0.5)             #shifts them down so its the distance from any integer
                    print_array(f"Optimal iterations for {i} Qubits is: {op_iter:.3f}")
                    if int_dist > int_val:            #iterates through to find the smallest distance from an integer
                        self.n = i
                        int_val = int_dist
                search_space: int = 2**self.n       #computes the final search space for the chosen n
                print_array("\n")
                print_array(f"Using {self.n} Qubits with a search space of {search_space} to get the best accuracy")
            else:
                raise QC_error(qc_dat.error_iterations)
        else:
            search_space = 2**self.n       #computes the search space for the n provided
            print_array(f"Using {self.n} Qubits and a search space of {search_space}")
        op_iter = round((np.pi/4)*np.sqrt((search_space)/len(self.oracle_values)) - 0.5)

        if self.it == 0:     #now picks an iteration value
            self.it = op_iter
            if self.it < 1:    #obviously we cant have no iterations so it atleast does 1 iteration
                self.it = 1.0000       #more of a failsafe, will almost certainly be wrong as the percentage diff from the it value to 1 will be large?
            print_array(f"Optimal number of iterations are: {self.it}")
        else:
            print_array(f"Number of iterations to perform are: {self.it}")
        qub = q0
        had_op = spec_had
        had_norm = 1/np.sqrt(2**self.n)   #applies the norm afterwards to be more efficient
        for i in range(self.n-1):    #creates the qubit and also the tensored hadamard for the given qubit size
            qub **= q0
            had_op **= spec_had
        it = 0
        while it < int(self.it):   #this is where the bulk of the computation actually occurs and is where the algorithm is actually applied
            if it != 0:
                qub = final_state
            initialized_qubit = had_op * qub       #applies a hadamard to every qubit                           STEP 1
            intermidary_qubit = had_op * self.phase_oracle(initialized_qubit, self.oracle_values)              #STEP 2   phase flips the given oracle values
            intermidary_qubit.vector *= -1           #inverts all of the phases of the qubit values             STEP 3a
            intermidary_qubit.vector[0] *= -1              #inverts back the first qubits phase                 STEP 3b
            final_state = had_op * intermidary_qubit        #applies yet another hadamard gate to the qubits    STEP 4
            it += 1                   #adds to the iteration counter
            print(f"\rIteration number: {it} ", end="")    #allows to clear line without writing a custom print function in print_array
        print_array("\n")
        final_state.vector *= had_norm**(3*int(self.it))             #applies the normalisation factor here
        final_state = final_state.prob_dist()                        #creates the prob distribution of the state
        sorted_arr = self.top_probs(final_state.matrix, len(self.oracle_values))         #finds the n top probabilities
        output = Grover(final_state.name, n=self.n, results=sorted_arr)         #creates a Grover instance
        output.name = f"The States of the Grover Search with Oracle Values {oracle_values}, after {int(self.it)} iterations is: "
        print_array(output)                #prints that Grover instance
        console.rule(f"", style="headers")
        return output              #returns the value

class print_array:    #made to try to make matrices look prettier
    def __init__(self, array):
        self.console = Console()  # Use Rich's Console for rich printing
        self.array = array
        self.prec = 2  # Default precision for numpy formatting
        np.set_printoptions(
            precision=self.prec,
            suppress=True,
            floatmode="fixed")
        
        if isinstance(array, Density):
            if array.dim < 9:
                np.set_printoptions(linewidth=(8 + 2 * self.prec) * array.dim)
            else:
                np.set_printoptions(linewidth=(7.5 + 2 * self.prec) * array.dim)
            console.print(array,markup=True,style="Density_style")
        elif isinstance(array, Prob_dist):
            ket_mat = np.arange(0,array.dim)
            num_bits = int(np.ceil(np.log2(array.dim)))
            np.set_printoptions(linewidth=(10))
            console.print(f"{array.name}",markup=True, style="Prob_dist_style")
            for ket_val, prob_val in zip(ket_mat,array.matrix):
                console.print(f"|{bin(ket_val)[2:].zfill(num_bits)}>  {prob_val:.{3}f}",markup=True, style="Prob_dist_style")
        elif isinstance(array, Grover):
            console.print(array,markup=True, style="Prob_dist_style")
        elif isinstance(array, Qubit):
            np.set_printoptions(linewidth=(10))
            console.print(array,markup=True,style="Qubit_style")
        elif isinstance(array, Gate):
            if array.dim < 9:
                np.set_printoptions(linewidth=(8 + 2 * self.prec) * array.dim)
            else:
                np.set_printoptions(linewidth=(8 + 2 * self.prec) * array.dim)
            console.print(array,markup=True,style="Gate_style")
        else:
            console.print(array,markup=True,style="White")

X_Gate = Gate.X_Gate()             #initialises the default gates
Y_Gate = Gate.Y_Gate()
Z_Gate = Gate.Z_Gate()
Identity = Gate.Identity()
Hadamard = Gate.Hadamard()
CNot_flip = Gate.C_Gate(qubit1=2, qubit2=1, info=qc_dat.C_Not_matrix,name="CNot_flip")
CNot = Gate.C_Gate(info=qc_dat.C_Not_matrix,name="CNot")

qub = q1 @ q1 @ q1
def fractional_binary(qub,m):             #for shors
    num_bits = int(np.ceil(np.log2(qub.dim)))
    x_vals = qub.name[1:1+num_bits]
    frac_bin = ("0." + x_vals)
    val = 0
    if m <= num_bits:
        for i in range(m):
            val += float(frac_bin[i+2])*2**-(i+1)
            print(float(frac_bin[i+2]))
        print("new func")
        return val
qub = q1 @ q1 @ q1 
def quant_fourier_trans(qub):          #also for shors although used in other algorithms
    old_name = qub.name
    n = int(np.ceil(np.log2(qub.dim)))
    frac_init = fractional_binary(qub,1)
    four_qub_init = Qubit(vector=np.array([1,np.exp(2*1j*np.pi*frac_init)]))
    print_array(four_qub_init)
    four_qub_init.norm()
    four_qub_sum = four_qub_init
    for j in range(n-1):
        frac = fractional_binary(qub,j+2)
        four_qub = Qubit(vector=np.array([1,np.exp(2*1j*np.pi*frac)]))
        four_qub.norm()
        print_array(four_qub)
        four_qub_sum **= four_qub
    four_qub_sum.name = f"QFT of {old_name}"
    return four_qub_sum

def alg_template(qub):         #make sure to mat mult the correct order
    console.rule(f"Algorithm acting on {qub.name} state", style="headers")
    gate1 = CNot
    gate2 = CNot_flip
    gate3 = CNot
    alg = gate3 * gate2 * gate1
    print_array(alg)
    _pd_result = qub.prob_dist(alg)
    result = qub.measure(alg)
    print_array(_pd_result)
    print_array(result)
qub = q0 @ q0
#alg_template(qub)

def alg_template2(qub):         #make sure to mat mult the correct order
    console.rule(f"Algorithm acting on {qub.name} state", style="headers")
    gate1 = X_Gate @ X_Gate @ X_Gate
    alg = gate1
    _pd_result = qub.prob_dist(alg)
    result = qub.measure(alg)
    print_array(_pd_result)
    print_array(result)
qub = q0 @ q0 @ q1
#alg_template2(qub)
oracle_values = [200, 199, 100,10,1]

Grover(oracle_values).run()